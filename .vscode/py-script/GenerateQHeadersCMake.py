import os
from pathlib import Path

def find_qobject_headers(project_dir_str: str, excluded_dirs: list = None):
    """
    Finds header files containing Q_OBJECT within the project directory,
    excluding specified subdirectories, and generates a list of CMake-compatible paths.
    """
    project_path = Path(project_dir_str)
    if not project_path.is_dir():
        print(f"Error: Project directory '{project_dir_str}' does not exist or is not a directory.")
        return None

    if excluded_dirs is None:
        excluded_dirs = []

    normalized_excluded_paths = [project_path / Path(d) for d in excluded_dirs]

    q_object_headers_relative_paths = []
    header_extensions = ("*.h", "*.hpp", "*.hxx")

    print(f"Scanning for headers in: {project_path}")
    if normalized_excluded_paths:
        print(f"Full paths being excluded: {[str(p) for p in normalized_excluded_paths]}")


    for ext in header_extensions:
        for header_file in project_path.rglob(ext):
            is_excluded = False
            for excluded_path in normalized_excluded_paths:
                try:
                    if header_file.is_relative_to(excluded_path): # Python 3.9+
                        is_excluded = True
                        break
                except AttributeError: # For Python < 3.9
                    try:
                        header_file.relative_to(excluded_path)
                        is_excluded = True
                        break
                    except ValueError:
                        pass

            if is_excluded:
                print(f"Skipping (excluded due to rule): {header_file}") # 调试打印
                continue

            try:
                content = header_file.read_text(encoding='utf-8', errors='ignore')
                if "Q_OBJECT" in content:
                    relative_path = header_file.relative_to(project_path)
                    relative_path_str = str(relative_path).replace('\\', '/')
                    q_object_headers_relative_paths.append(relative_path_str)
                    print(f"Found Q_OBJECT in: {header_file} (relative: {relative_path_str})")
            except Exception as e:
                print(f"Warning: Could not read or process file {header_file}: {e}")

    return q_object_headers_relative_paths

def generate_cmake_file(project_dir_str: str, relative_header_paths: list):
    project_path = Path(project_dir_str)
    cmake_subdir = project_path / "cmake"
    try:
        cmake_subdir.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        print(f"Error: Could not create 'cmake' subdirectory at {cmake_subdir}: {e}")
        return

    output_file_path = cmake_subdir / "QHeaders.cmake"
    cmake_content = "# QHeaders.cmake (Auto-generated by Python script)\n"
    cmake_content += "# Contains headers with Q_OBJECT macro for Qt MOC.\n\n"

    if not relative_header_paths:
        cmake_content += "set(Q_HEADERS)\n"
        cmake_content += "# No headers with Q_OBJECT found.\n"
    else:
        cmake_content += "set(Q_HEADERS\n"
        for rel_path in sorted(relative_header_paths):
            # Assuming CMAKE_SOURCE_DIR is PROJECT_DIR and headers are inside PROJECT_DIR
            # If you confirmed `${CMAKE_SOURCE_DIR}/../${rel_path}` was correct, revert this.
            # But typically for headers inside the project, `${CMAKE_SOURCE_DIR}/${rel_path}` is what you want.
            cmake_path_entry = f"${{CMAKE_SOURCE_DIR}}/{rel_path}"
            cmake_content += f"        {cmake_path_entry}\n"
        cmake_content += ")\n"

    try:
        output_file_path.write_text(cmake_content, encoding='utf-8')
        print(f"\nSuccessfully generated CMake file: {output_file_path}")
        print("Content:\n----------\n" + cmake_content.strip() + "\n----------")
    except Exception as e:
        print(f"Error: Could not write to {output_file_path}: {e}")


def main():
    project_dir = os.environ.get("PROJECT_DIR")

    if not project_dir:
        print("Error: The environment variable PROJECT_DIR is not set.")
        print("Please set PROJECT_DIR to your project's root directory.")
        # For testing:
        # project_dir = "." # Example: current directory
        # if not os.environ.get("PROJECT_DIR"):
        #     print(f"Warning: PROJECT_DIR not set, using '{project_dir}' for testing.")
        #     # return # Uncomment if you want to exit if PROJECT_DIR is not set
        # For example, if PROJECT_DIR is not set, use a default for testing:
        # if not project_dir:
        #     project_dir = "/path/to/your/test_project" # REPLACE WITH ACTUAL PATH FOR TESTING
        #     print(f"PROJECT_DIR not set, using hardcoded: {project_dir}")
        if not project_dir: return # Exit if not set and no default provided for testing

    print(f"Project directory (from PROJECT_DIR env var or test default): {project_dir}")

    # --- 关键修改在这里 ---
    # 定义 directories_to_exclude 列表
    # 如果 crash_handler 目录在 PROJECT_DIR/app/crashhandler
    directories_to_exclude = [
        "app/crashhandler","ext"
        # "another_project_to_exclude" # Add other paths relative to PROJECT_DIR if needed
    ]
    # 如果 crash_handler 目录是 PROJECT_DIR/crash_handler (直接在根目录下)
    # directories_to_exclude = ["crash_handler"]

    print(f"Attempting to exclude subdirectories (relative to project dir): {directories_to_exclude}")

    relative_header_paths = find_qobject_headers(project_dir, excluded_dirs=directories_to_exclude)

    if relative_header_paths is not None:
        generate_cmake_file(project_dir, relative_header_paths)

if __name__ == "__main__":
    main()